### 1.4、依赖

一个典型的企业级应用不仅仅包含一个对象（也就是在Spring说法中的bean）。即使最简单的应用也有一些一块协作的对象来作为一个连贯的应用展现给用户。下一小结展示了如何从单独定义一些bean定义到如何通过对象之间的合作实现一个完整的应用程序。

#### 1.4.1 依赖注入

依赖注入\(DI\)是对象定义他们的依赖\(也就是说，与该对象一快协作的对象\)的过程，该过程仅仅通过构造器参数，工厂方法参数，被构造器构造或工厂方法返回的实例设置属性来工作。当容器创建bean的时候，注入这些依赖。该过程与bean自己控制实例化或通过类或服务定位器模式直接构造依赖的方式正好是相反的，因此得名，控制反转。

使用DI规则编码更干净，当对象具有依赖关系时，解耦更有效。对象不用搜索他的依赖，并且不用知道依赖的位置或类。因此，你的类将使得测试更为简单，特别是当依赖在接口或基本抽象类中的时候，这允许在单元测试中使用存根或模拟实现。

DI主要有两种主要的变体：基于构造器的依赖注入和基于Setter方法的依赖注入。

##### 基于构造器的依赖注入

基于构造器的依赖注入是由容器调用一个带有多个参数的构造器实现的，构造器中的每一个参数都代表一个依赖。调用一个带有特定参数的`static`工厂方法来构建bean接近相同，这个讨论类似的处理构造函数和静态工厂方法的参数。下述的例子展示了一个只能通过使用构造器注入进行依赖注入的类：

```
public class SimpleMovieListener{
    // SimpleMovieListener有一个MovieFinder的依赖
    private MovieFinder movieFinder;

    // Spring容器能够注入一个MovieFinder的构造器
    public SimpleMovieListener(MovieFinder movieFinder){
        this.movieFinder = movieFinder;
    }

    // 实际使用被注入的MovieFinder的业务逻辑被省略...
}
```

注意，这个类并没有特别的地方。这就是一个没有依赖，没有容器特定的接口，基本类或注解的POJO\(Plain Ordinary Java Object，简单Java对象\)。

